---
title: "Propensity Score Matching and Analysis"
author: "Satoshi Ido"
output: html_document
header-includes:
  - "\\usepackage{listings}"
  - "\\lstset{breaklines=true,breakatwhitespace=true}"
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  tidy = TRUE
)
```
```{r}
library("ggplot2")
library("tidyverse")
library("MASS")
library("broom")
```

```{r warning=FALSE, message=FALSE, include=FALSE}
# Create the input_dir (input directory)
INPUT_DIR <- "/Users/satoshiido/Documents/programming/statistical-analysis/causal_inference/data"

# If INPUT_DIR has not been created yet, create it
if (!dir.exists(INPUT_DIR)) {
  dir.create(INPUT_DIR)
}

# Create the output_dir (output directory)
OUTPUT_DIR <- "/Users/satoshiido/Documents/programming/statistical-analysis/causal_inference/output"

# If OUTPUT_DIR has not been created yet, create it
if (!dir.exists(OUTPUT_DIR)) {
  dir.create(OUTPUT_DIR)
}

# Read CSV files using a function to specify the directory automatically
read_csv <- function(name, ...) {
  path <- file.path(INPUT_DIR, paste0(name, ".csv"))
  print(paste("Load:", path))
  return(read.csv(path, ...))
}
```

```{r warning=FALSE, message=FALSE}
email_data <- read_csv("Kevin_Hillstrom_MineThatData_E-MailAnalytics_DataMiningChallenge_2008.03.20")
head(email_data)
```

```{r warning=FALSE, message=FALSE}
# create the data w/o the womens E-Mail campaign
male_df <- email_data %>% 
  filter(segment != "Womens E-Mail") %>%
  mutate(treatment = if_else(segment == "Mens E-Mail", 1, 0))

# create the selection biased data
## set the seed
set.seed(1)

## make half depending on the condition
obs_rate_c <- 0.5
obs_rate_t <- 0.5

## create the biased data
biased_data <- male_df %>%
  mutate(
    obs_rate_c = if_else(
      (history > 300) | (recency < 6) | (channel == "Multichannel"), obs_rate_c, 1),
    obs_rate_t = if_else(
      (history > 300) | (recency < 6) | (channel == "Multichannel"), 1, obs_rate_t),
    random_number = runif(n = NROW(male_df))) %>%
    filter((treatment == 0 & random_number < obs_rate_c) | (treatment == 1 & random_number < obs_rate_t))

head(biased_data)
```

# Propensity Score Estimation
```{r warning=FALSE, message=FALSE}
# create the propensity score model using logistic regression, which returns the probability of Y = 1
ps_model <- glm(data = biased_data, formula = treatment ~ recency + history + channel, family = binomial)
```

# Propensity Score Matching
The idea is very simple. A sample is taken from the intervention group and matched with a sample from the non-intervention group that has a propensity score close to that of the sample to form a pair. The difference in the objective variable among the pairs is then calculated and averaged to obtain an estimate of the effect.
Average Treatment effect on Treated (ATT) is defined as follows:
$$
ATT = E[Y(1) - Y(0)] = E[Y|T=1] - E[Y|T=0]
$$

```{r warning=FALSE, message=FALSE}
library("MatchIt")

# perform propensity score matching (matchit -> ATT)
m_near <- matchit(formula = treatment ~ recency + history + channel,
  data = biased_data,
  method = "nearest",
  replace = TRUE)

# get the matched data (The resulting data frame will include all of the original data, along with additional columns for the weights and indices of the matched observations.)
matched_data <- match.data(m_near)

# estimate the effect based on the matched data
PSM_result <- matched_data %>% 
  lm(spend ~ treatment, data = .) %>%
  tidy()
```

# Inverse Probability Weighting; IPW
Using the propensity scores as sample weights, we estimate the expected value of the outcome with intervention (E[Y(1)]) and the expected value of the outcome without intervention (E[Y(0)]) for the given data as a whole. The effect is then estimated by subtracting these expected values
PW uses the value of the propensity score to strech the observed sample size. This increases the number of samples with small Y(1) values, which are relatively difficult to observe due to Z = 0, thus bringing the calculated average closer to the original expected value.

```{r warning=FALSE, message=FALSE}
library("WeightIt")

# perform inverse probability weighting (weightit -> ATE)
weighting <- weightit(formula = treatment ~ recency + history + channel,
  data = biased_data,
  method = "ps",
  estimand = "ATE")

# estimate the effect based on the weighted data
IPW_result <- biased_data %>%
  lm(formula = spend ~ treatment, weights = weighting$weights) %>%
  tidy()

IPW_result
```
